a<-(mean(data1_transformed)-mean(data0_transformed))/sqrt(var(data1_transformed)*(length(data1)-1)/length(data1))
b<-sqrt(var(data0_transformed)*(length(data0)-1)/length(data0))/sqrt(var(data1_transformed)*(length(data1)-1)/length(data1))
var_a<-(n0*(a^2+2)+2*n1*b^2)/(2*n0*n1)
var_b<-(n1+n0)*b^2/(2*n0*n1)
covar_ab<-a*b/(2*length(data1))
area.full<-pnorm(a/sqrt(1+b^2))
#输出结果
output<-list(lambda=NULL,a=NULL,b=NULL,var_a=NULL,var_b=NULL,covar_ab=NULL,area.full=NULL)
output$lambda<-lambda
output$a<-a
output$b<-b
output$var_a<-var_a
output$var_b<-var_b
output$covar_ab<-covar_ab
output$area.full<-area.full
return(output)
}
roc.continuous<-function(data0,data1){
output<-list(lambda=NULL,a=NULL,b=NULL,var_a=NULL,var_b=NULL,covar_ab=NULL,area.full=NULL)
if(length(data0)>=50&&length(data1)>=50){
output$lambda<-BoxCox(data0,data1)$lambda
output$a<-BoxCox(data0,data1)$a
output$b<-BoxCox(data0,data1)$b
output$var_a<-BoxCox(data0,data1)$var_a
output$var_b<-BoxCox(data0,data1)$var_b
output$covar_ab<-BoxCox(data0,data1)$covar_ab
output$area.full<-BoxCox(data0,data1)$area.full
}
else{
B<-1000
a_seq<-rep(0,B)
b_seq<-rep(0,B)
boot<-1
while(boot<=B){
if(sum(BoxCox(data0,data1)$data0_transformed==1)!=length(data0)){
tmp0<-sample(data0,length(data0),replace=TRUE)
tmp1<-sample(data1,length(data1),replace=TRUE)
a_seq[boot]<-BoxCox(tmp0,tmp1)$a
b_seq[boot]<-BoxCox(tmp0,tmp1)$b
boot<-boot+1
}
}
output$lambda<-BoxCox(data0,data1)$lambda
output$a<-BoxCox(data0,data1)$a
output$b<-BoxCox(data0,data1)$b
output$var_a<-var(a_seq)
output$var_b<-var(b_seq)
output$covar_ab<-cov(a_seq,b_seq)
output$area.full<-BoxCox(data0,data1)$area.full
}
a<-BoxCox(data0,data1)$a
b<-BoxCox(data0,data1)$b
#绘制曲线
x<-seq(0,1,length=10000)
y<-rep(0,length=10000)
for(i in 1:10000){
y[i]<-pnorm(a+b*qnorm(x[i]))
}
plot(x,y,type="l",main="Estimation of Smooth ROC Curve",xlab="FPR",ylab="Se",col="purple")
return(output)
}
data0<-c(136,286,281,23,200,146,220,96,100,60,17,27,126,100,253,70,40,6,46)
data1<-c(140,1087,230,183,1256,700,16,800,253,740,126,153,283,90,303,193,76,1370,543,913,230,463,60,509,576,671,80,490,156,356,350,323,1560,120,216,443,523,76,303,353,206)
roc.continuous(data0,data1)
data1_yes<-c(140,1087,230,183,1256,700,16,800,253,740,126,153,283,90,303,193)
data2_yes<-c(76,1370,543,913,230,463,60,509,576,671,80,490,156,356,350,323,1560,120,216,443,523,76,303,353,206)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
BoxCox<-function(data0,data1){
loglikelihood<-function(lambda){
data0_transformed<-rep(0,length=length(data0))
for(i in 1:length(data0)){
if(lambda!=0&&!is.na(lambda)){
data0_transformed[i]<-(data0[i]^lambda-1)/lambda
}
else{
data0_transformed[i]<-log(data0[i])
}
}
mean0<-mean(data0_transformed)
var0<-var(data0_transformed)*(length(data0-1))/length(data0)
result0<-log(sqrt(var0))*(-length(data0))
for(i in 1:length(data0)){
result0<-result0+log(data0[i]^(lambda-1))-(data0_transformed[i]-mean0)^2/(2*var0)
}
data1_transformed<-rep(0,length=length(data1))
for(i in 1:length(data1)){
if(lambda!=0&&!is.na(lambda)){
data1_transformed[i]<-(data1[i]^lambda-1)/lambda
}
else{
data1_transformed[i]<-log(data1[i])
}
}
mean1<-mean(data1_transformed)
var1<-var(data1_transformed)*(length(data1)-1)/length(data1)
result1<-log(sqrt(var1))*(-length(data1))
for(i in 1:length(data1)){
result1<-result1+log(data1[i]^(lambda-1))-(data1_transformed[i]-mean1)^2/(2*var1)
}
return(-result0-result1)
}
start_param<-1
suppressWarnings({
result<-nlminb(start_param,loglikelihood)
})
lambda<-result$par
data0_transformed<-rep(0,length=length(data0))
for(i in 1:length(data0)){
if(lambda!=0&&!is.na(lambda)){
data0_transformed[i]<-(data0[i]^lambda-1)/lambda
}
else if(lambda==0){
data0_transformed[i]<-log(data0[i])
}
else{
data0_transformed[i]<-rep(1,length(data0))
}
}
data1_transformed<-rep(0,length=length(data1))
for(i in 1:length(data1)){
if(lambda!=0&&!is.na(lambda)){
data1_transformed[i]<-(data1[i]^lambda-1)/lambda
}
else if(lambda==0){
data1_transformed[i]<-log(data1[i])
}
else{
data1_transformed[i]<-rep(1,length(data1))
}
}
n0<-length(data0)
n1<-length(data1)
a<-(mean(data1_transformed)-mean(data0_transformed))/sqrt(var(data1_transformed)*(length(data1)-1)/length(data1))
b<-sqrt(var(data0_transformed)*(length(data0)-1)/length(data0))/sqrt(var(data1_transformed)*(length(data1)-1)/length(data1))
var_a<-(n0*(a^2+2)+2*n1*b^2)/(2*n0*n1)
var_b<-(n1+n0)*b^2/(2*n0*n1)
covar_ab<-a*b/(2*length(data1))
area.full<-pnorm(a/sqrt(1+b^2))
#输出结果
output<-list(lambda=NULL,a=NULL,b=NULL,var_a=NULL,var_b=NULL,covar_ab=NULL,area.full=NULL)
output$lambda<-lambda
output$a<-a
output$b<-b
output$var_a<-var_a
output$var_b<-var_b
output$covar_ab<-covar_ab
output$area.full<-area.full
return(output)
}
roc.continuous<-function(data0,data1){
output<-list(lambda=NULL,a=NULL,b=NULL,var_a=NULL,var_b=NULL,covar_ab=NULL,area.full=NULL)
if(length(data0)>=50&&length(data1)>=50){
output$lambda<-BoxCox(data0,data1)$lambda
output$a<-BoxCox(data0,data1)$a
output$b<-BoxCox(data0,data1)$b
output$var_a<-BoxCox(data0,data1)$var_a
output$var_b<-BoxCox(data0,data1)$var_b
output$covar_ab<-BoxCox(data0,data1)$covar_ab
output$area.full<-BoxCox(data0,data1)$area.full
}
else{
B<-5000
a_seq<-rep(0,B)
b_seq<-rep(0,B)
boot<-1
while(boot<=B){
if(sum(BoxCox(data0,data1)$data0_transformed==1)!=length(data0)){
tmp0<-sample(data0,length(data0),replace=TRUE)
tmp1<-sample(data1,length(data1),replace=TRUE)
a_seq[boot]<-BoxCox(tmp0,tmp1)$a
b_seq[boot]<-BoxCox(tmp0,tmp1)$b
boot<-boot+1
}
}
output$lambda<-BoxCox(data0,data1)$lambda
output$a<-BoxCox(data0,data1)$a
output$b<-BoxCox(data0,data1)$b
output$var_a<-var(a_seq)
output$var_b<-var(b_seq)
output$covar_ab<-cov(a_seq,b_seq)
output$area.full<-BoxCox(data0,data1)$area.full
}
a<-BoxCox(data0,data1)$a
b<-BoxCox(data0,data1)$b
#绘制曲线
x<-seq(0,1,length=10000)
y<-rep(0,length=10000)
for(i in 1:10000){
y[i]<-pnorm(a+b*qnorm(x[i]))
}
plot(x,y,type="l",main="Estimation of Smooth ROC Curve",xlab="FPR",ylab="Se",col="purple")
return(output)
}
roc.continuous(data0,data1)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
roc.continuous(data0,data1)
#4.3.2 Fitting a Smooth ROC Curve
#Parametric Method
#' function that uses parametric method to fully analyze continuous data
#' using a Box-Cox transformation to transform data to normal data,and then analyze it
#' @param data0 continuous test results of nondiseased subjects
#' @param data1 continuous test results of diseased subjects
#' @return binormal parameters,estimation of their variances and covariance,and full area under ROC
#' @export
roc.continuous<-function(data0,data1){
loglikelihood<-function(lambda){
data0_transformed<-rep(0,length=length(data0))
for(i in 1:length(data0)){
if(lambda!=0){
data0_transformed[i]<-(data0[i]^lambda-1)/lambda
}
else{
data0_transformed[i]<-log(data0[i])
}
}
mean0<-mean(data0_transformed)
var0<-var(data0_transformed)*(length(data0-1))/length(data0)
result0<-log(sqrt(var0))*(-length(data0))
for(i in 1:length(data0)){
result0<-result0+log(data0[i]^(lambda-1))-(data0_transformed[i]-mean0)^2/(2*var0)
}
data1_transformed<-rep(0,length=length(data1))
for(i in 1:length(data1)){
if(lambda!=0){
data1_transformed[i]<-(data1[i]^lambda-1)/lambda
}
else{
data1_transformed[i]<-log(data1[i])
}
}
mean1<-mean(data1_transformed)
var1<-var(data1_transformed)*(length(data1)-1)/length(data1)
result1<-log(sqrt(var1))*(-length(data1))
for(i in 1:length(data1)){
result1<-result1+log(data1[i]^(lambda-1))-(data1_transformed[i]-mean1)^2/(2*var1)
}
return(-result0-result1)
}
start_param<-1
result<-optim(par=start_param,fn=loglikelihood,method="BFGS")
lambda<-result$par
data0_transformed<-rep(0,length=length(data0))
for(i in 1:length(data0)){
if(lambda!=0){
data0_transformed[i]<-(data0[i]^lambda-1)/lambda
}
else{
data0_transformed[i]<-log(data0[i])
}
}
data1_transformed<-rep(0,length=length(data1))
for(i in 1:length(data1)){
if(lambda!=0){
data1_transformed[i]<-(data1[i]^lambda-1)/lambda
}
else{
data1_transformed[i]<-log(data1[i])
}
}
n0<-length(data0)
n1<-length(data1)
a<-(mean(data1_transformed)-mean(data0_transformed))/sqrt(var(data1_transformed)*(length(data1)-1)/length(data1))
b<-sqrt(var(data0_transformed)*(length(data0)-1)/length(data0))/sqrt(var(data1_transformed)*(length(data1)-1)/length(data1))
var_a<-(n0*(a^2+2)+2*n1*b^2)/(2*n0*n1)
var_b<-(n1+n0)*b^2/(2*n0*n1)
covar_ab<-a*b/(2*length(data1))
area.full<-pnorm(a/sqrt(1+b^2))
#绘制曲线
x<-seq(0,1,length=10000)
y<-rep(0,length=10000)
for(i in 1:10000){
y[i]<-pnorm(a+b*qnorm(x[i]))
}
plot(x,y,type="l",main="Estimation of Smooth ROC Curve",xlab="FPR",ylab="Se",col="purple")
#输出结果
output<-list(lambda=NULL,a=NULL,b=NULL,var_a=NULL,var_b=NULL,covar_ab=NULL,area.full=NULL)
output$lambda<-lambda
output$a<-a
output$b<-b
output$var_a<-var_a
output$var_b<-var_b
output$covar_ab<-covar_ab
output$area.full<-area.full
return(output)
}
roc.continuous(data0,data1)
data0<-c(data0,data0)
data1<-c(data1,data1)
roc.continuous(data0,data1)
BoxCox<-function(data0,data1){
loglikelihood<-function(lambda){
data0_transformed<-rep(0,length=length(data0))
for(i in 1:length(data0)){
if(lambda!=0&&!is.na(lambda)){
data0_transformed[i]<-(data0[i]^lambda-1)/lambda
}
else{
data0_transformed[i]<-log(data0[i])
}
}
mean0<-mean(data0_transformed)
var0<-var(data0_transformed)*(length(data0-1))/length(data0)
result0<-log(sqrt(var0))*(-length(data0))
for(i in 1:length(data0)){
result0<-result0+log(data0[i]^(lambda-1))-(data0_transformed[i]-mean0)^2/(2*var0)
}
data1_transformed<-rep(0,length=length(data1))
for(i in 1:length(data1)){
if(lambda!=0&&!is.na(lambda)){
data1_transformed[i]<-(data1[i]^lambda-1)/lambda
}
else{
data1_transformed[i]<-log(data1[i])
}
}
mean1<-mean(data1_transformed)
var1<-var(data1_transformed)*(length(data1)-1)/length(data1)
result1<-log(sqrt(var1))*(-length(data1))
for(i in 1:length(data1)){
result1<-result1+log(data1[i]^(lambda-1))-(data1_transformed[i]-mean1)^2/(2*var1)
}
return(-result0-result1)
}
start_param<-1
suppressWarnings({
result<-nlminb(start_param,loglikelihood)
})
lambda<-result$par
data0_transformed<-rep(0,length=length(data0))
for(i in 1:length(data0)){
if(lambda!=0&&!is.na(lambda)){
data0_transformed[i]<-(data0[i]^lambda-1)/lambda
}
else if(lambda==0){
data0_transformed[i]<-log(data0[i])
}
else{
data0_transformed[i]<-rep(1,length(data0))
}
}
data1_transformed<-rep(0,length=length(data1))
for(i in 1:length(data1)){
if(lambda!=0&&!is.na(lambda)){
data1_transformed[i]<-(data1[i]^lambda-1)/lambda
}
else if(lambda==0){
data1_transformed[i]<-log(data1[i])
}
else{
data1_transformed[i]<-rep(1,length(data1))
}
}
n0<-length(data0)
n1<-length(data1)
a<-(mean(data1_transformed)-mean(data0_transformed))/sqrt(var(data1_transformed)*(length(data1)-1)/length(data1))
b<-sqrt(var(data0_transformed)*(length(data0)-1)/length(data0))/sqrt(var(data1_transformed)*(length(data1)-1)/length(data1))
var_a<-(n0*(a^2+2)+2*n1*b^2)/(2*n0*n1)
var_b<-(n1+n0)*b^2/(2*n0*n1)
covar_ab<-a*b/(2*length(data1))
area.full<-pnorm(a/sqrt(1+b^2))
#输出结果
output<-list(lambda=NULL,a=NULL,b=NULL,var_a=NULL,var_b=NULL,covar_ab=NULL,area.full=NULL)
output$lambda<-lambda
output$a<-a
output$b<-b
output$var_a<-var_a
output$var_b<-var_b
output$covar_ab<-covar_ab
output$area.full<-area.full
return(output)
}
roc.continuous<-function(data0,data1){
output<-list(lambda=NULL,a=NULL,b=NULL,var_a=NULL,var_b=NULL,covar_ab=NULL,area.full=NULL)
if(length(data0)>=50&&length(data1)>=50){
output$lambda<-BoxCox(data0,data1)$lambda
output$a<-BoxCox(data0,data1)$a
output$b<-BoxCox(data0,data1)$b
output$var_a<-BoxCox(data0,data1)$var_a
output$var_b<-BoxCox(data0,data1)$var_b
output$covar_ab<-BoxCox(data0,data1)$covar_ab
output$area.full<-BoxCox(data0,data1)$area.full
}
else{
B<-1000
a_seq<-rep(0,B)
b_seq<-rep(0,B)
boot<-1
while(boot<=B){
if(sum(BoxCox(data0,data1)$data0_transformed==1)!=length(data0)){
tmp0<-sample(data0,length(data0),replace=TRUE)
tmp1<-sample(data1,length(data1),replace=TRUE)
a_seq[boot]<-BoxCox(tmp0,tmp1)$a
b_seq[boot]<-BoxCox(tmp0,tmp1)$b
boot<-boot+1
}
}
output$lambda<-BoxCox(data0,data1)$lambda
output$a<-BoxCox(data0,data1)$a
output$b<-BoxCox(data0,data1)$b
output$var_a<-var(a_seq)
output$var_b<-var(b_seq)
output$covar_ab<-cov(a_seq,b_seq)
output$area.full<-BoxCox(data0,data1)$area.full
}
a<-BoxCox(data0,data1)$a
b<-BoxCox(data0,data1)$b
#绘制曲线
x<-seq(0,1,length=10000)
y<-rep(0,length=10000)
for(i in 1:10000){
y[i]<-pnorm(a+b*qnorm(x[i]))
}
plot(x,y,type="l",main="Estimation of Smooth ROC Curve",xlab="FPR",ylab="Se",col="purple")
return(output)
}
roc.continuous(data0,data1)
50^31/exp(50)
100^31/exp(100)
1000^31/exp(1000)
200^31/exp(200)
library(devtools)
check()
check()
check()
build()
devtools::install("/Users/zhanghaoran/Desktop/Chapter4_0.1.0.tar.gz")
devtools::install("/Users/zhanghaoran/Desktop/Chapter4")
params_estimate
params_estimate_ordinal_paired<-function(data0,data1){
K<-nrow(data0)
distribution0 <- matrix(0,nrow=K,ncol=K)
distribution1 <- matrix(0,nrow=K,ncol=K)
n0<-sum(data0)
n1<-sum(data1)
#----------------计算对数似然函数
loglikelihood<-function(params) {
#两个test的decision thresholds
th1<-c(-Inf,params[1:(K-1)],Inf)
th2<-c(-Inf,params[K:(2*K-2)],Inf)
#_前的1/2表示是哪一个test,_后的0/1表示是否患病
mu1_0<-0
sigma1_0<-1
mu2_0<-0
sigma2_0<-1
rho_0<-params[2*K-1]
rho_1<-params[2*K]
a1<-params[2*K+1]
b1<-params[2*K+2]
a2<-params[2*K+3]
b2<-params[2*K+4]
mu1_1<-a1*sigma1_0/b1+mu1_0
mu2_1<-a2*sigma2_0/b2+mu2_0
sigma1_1<-sigma1_0/b1
sigma2_1<-sigma2_0/b2
#参数要在合理范围内
if(any(diff(th1)<0)||any(diff(th2)<0)){
return(Inf)
}
if(b1<=0||b2<=0){
return(Inf)
}
if(sigma1_0<=0||sigma1_1<=0){
return(Inf)
}
if(sigma2_0<=0||sigma2_1<=0){
return(Inf)
}
if(abs(rho_0)>=1||abs(rho_1)>=1){
return(Inf)
}
#undiseased individual,diseased individual的test result都服从二元正态分布
#对于undiseased,diseased中的每个个体,计算paired test result(X,Y)的分布
for(i in 1:K){
for(j in 1:K) {
distribution0[i,j]<-pmvnorm(lower=c(th1[i],th2[j]),upper=c(th1[i+1],th2[j+1]),mean=c(mu1_0,mu2_0),sigma=matrix(c(sigma1_0^2,rho_0*sigma1_0*sigma2_0,rho_0*sigma1_0*sigma2_0,sigma2_0^2),nrow=2,byrow=TRUE))
distribution1[i,j]<-pmvnorm(lower=c(th1[i],th2[j]),upper=c(th1[i+1],th2[j+1]),mean=c(mu1_1,mu2_1),sigma=matrix(c(sigma1_1^2,rho_1*sigma1_1*sigma2_1,rho_1*sigma1_1*sigma2_1,sigma2_1^2),nrow=2,byrow=TRUE))
}
}
#计算对数似然函数(不考虑多项分布系数)
return(-sum(data0*log(distribution0))-sum(data1*log(distribution1)))
}
#优化并输出结果
start_params<-c(seq(0,1,length=K-1),seq(0,1,length=K-1),0.5,0.5,1,1,1,1)
result<-nlminb(start_params,loglikelihood)
print(result)
hessian<-numDeriv::hessian(loglikelihood,result$par)
cov_matrix<-solve(hessian)
estimation<-list(a1=NULL,b1=NULL,a2=NULL,b2=NULL,cov_matrix=NULL)
estimation$a1<-result$par[2*K+1]
estimation$b1<-result$par[2*K+2]
estimation$a2<-result$par[2*K+3]
estimation$b2<-result$par[2*K+4]
estimation$cov_matrix<-cov_matrix[(2*K+1):(2*K+4),(2*K+1):(2*K+4)]
return(estimation)
}
data0<-matrix(c(36,20,8,6,0,0,3,3,1,0,0,1,0,4,0,0,0,2,3,2,2,1,2,5,2),nrow=5,byrow=TRUE)
data1<-matrix(c(1,2,2,2,1,0,0,0,0,2,0,0,0,2,0,0,0,0,2,0,0,0,1,8,39),nrow=5,byrow=TRUE)
params_estimate_ordinal_paired(data0,data1)
library(mvtnorm)
params_estimate_ordinal_paired(data0,data1)
library(devtools)
check()
